# Aprendendo Linguagem C

[![bit-community.png](https://i.postimg.cc/sDGGYNpx/c2-360x240.png)](https://postimg.cc/nCZLZTSf)     

___*Desenvolvimento*___ e ___*Aprendizagem*___ em ___*Linguagem de Programa√ß√£o C*___

Reposit√≥rio respons√°vel por arquivar o conhecimento adquirido durante a aporendizagem.

## Como pretendo aprender?! üìô

Durante essa escalada em busca do conhecimento desta linguagem utilizarei o Livro ___*C - Como programar*__ de Paul Deitel! [![download.jpg](https://i.postimg.cc/2jbr36gm/download.jpg)](https://postimg.cc/jCbGFssk)

Roteiro e lista de Tarefas:

**1. Introdu√ß√£o a LInguagem C**

- [ ] Programa C Simples: Imprimindo uma linha de Texto.
- [ ] Programa C Simples: Somando dois inteiros
- [ ] Aritm√©tica em C.
- [ ] Tomada de decis√µes: Operadores Relacionais e de Igualdade.

**2. Desenvolvimento estruturado de programas em C**
- [ ] Algoritmos, Pseudoc√≥digo.
- [ ] Estruturas de controle:
   * A estrutura de sele√ß√£o if.
   * A estrutura de sele√ß√£o if‚Ä¶else.
   * A estrutura de repeti√ß√£o while.
- [ ] Formulando algoritmos: 
   * Estudo de caso 1 (repeti√ß√£o controlada por contador).
- [ ] Formulando algoritmos com refinamentos sucessivos top-down:
   * Estudo de caso 2 (repeti√ß√£o controlada por sentinela).
- [ ] Formulando algoritmos com refinamentos sucessivos top-down:
   * Estudo de caso 3 (estruturas de controle aninhadas).
- [ ] Operadores de atribui√ß√£o.
- [ ] Operadores de incremento e decremento.

**3. Controle de programa em C**
- [ ] Repeti√ß√£o controlada por contador.
- [ ] A estrutura de repeti√ß√£o for.
- [ ] A estrutura de sele√ß√£o m√∫ltipla switch.
- [ ] A estrutura de repeti√ß√£o do‚Ä¶while.
   * Os comandos break e continue.

**4.Fun√ß√µes em C**
- [ ] M√≥dulos de programa em C.
- [ ] Fun√ß√µes da biblioteca matem√°tica.
- [ ] Fun√ß√µes.
   * Defini√ß√µes de fun√ß√µes.
   * Prot√≥tipos de fun√ß√µes.
   * Pilha de chamada de fun√ß√µes e registros de ativa√ß√£o.
   * Cabe√ßalhos.
   * Chamando fun√ß√µes por valor e por refer√™ncia.
- [ ] Gera√ß√£o de n√∫meros aleat√≥rios.
- [ ] Classes de armazenamento.
- [ ] Regras de escopo.
- [ ] Recurs√£o.
- [ ] Recurs√£o versus itera√ß√£o.

**5.Arrays (Matriz) em C**
- [ ] Arrays.
   * Declarando arrays.
   * Exemplos de arrays.
   * Passando arrays para fun√ß√µes.
   * Ordenando arrays.
   * Pesquisando arrays.
   * Arrays multidimensionais.
   
**6.Ponteiros em C**
- [ ] Declara√ß√µes e inicializa√ß√£o de vari√°veis-ponteiro.
- [ ] Operadores de ponteiros.
- [ ] Passando argumentos para fun√ß√µes por refer√™ncia.
- [ ] Usando o qualificador const com ponteiros.
- [ ] Bubble sort usando chamada por refer√™ncia.
- [ ] Operador sizeof.
- [ ] Express√µes com ponteiros e aritm√©tica de ponteiros.
- [ ] A rela√ß√£o entre ponteiros e arrays.
- [ ] Arrays de ponteiros.
   * Estudo de caso: uma simula√ß√£o de embaralhamento e distribui√ß√£o de cartas.
- [ ] Ponteiros para fun√ß√µes.

**7.Caracteres e strings em C**
- [ ] Fundamentos de strings e caracteres.
- [ ] Biblioteca de tratamento de caracteres.
- [ ] Fun√ß√µes de convers√£o de strings.
- [ ] Fun√ß√µes da biblioteca-padr√£o de entrada/sa√≠da.
- [ ] Fun√ß√µes de manipula√ß√£o de strings da biblioteca de tratamento de strings.
- [ ] Fun√ß√µes de compara√ß√£o da biblioteca de tratamento de strings.
- [ ] Fun√ß√µes de pesquisa da biblioteca de tratamento de strings.
- [ ] Fun√ß√µes de mem√≥ria da biblioteca de tratamento de strings.

**8.Entrada/sa√≠da formatada em C**
- [ ] Streams.
- [ ] Formata√ß√£o da sa√≠da com printf.
- [ ] Impress√£o de inteiros.
- [ ] Impress√£o de n√∫meros em ponto flutuante.
- [ ] Impress√£o de strings e caracteres.
- [ ] Outros especificadores de convers√£o.
- [ ] Impress√£o com larguras de campo e precis√£o.
- [ ] Uso de flags na string de controle de formato de printf.
- [ ] Impress√£o de literais e de sequ√™ncias de escape.
- [ ] Leitura da entrada formatada com scanf.

**9.Estruturas, uni√µes, manipula√ß√µes de bits e enumera√ß√µes em C**
- [ ] Declara√ß√µes de estruturas.
- [ ] Inicializa√ß√£o de estruturas.
- [ ] Acesso aos membros da estrutura.
- [ ] Uso de estruturas com fun√ß√µes.
- [ ] typedef.
- [ ] Uni√µes.
- [ ] Operadores sobre bits.
- [ ] Campos de bit.
- [ ] Constantes de enumera√ß√£o.

**Processamento de arquivos em C**
Hierarquia de dados.
Arquivos e streams.
Cria√ß√£o de um arquivo de acesso sequencial.
Leitura de dados de um arquivo de acesso sequencial.
Arquivos de acesso aleat√≥rio.
Cria√ß√£o de um arquivo de acesso aleat√≥rio.
Escrita aleat√≥ria de dados em um arquivo de acesso aleat√≥rio.
Leitura de dados de um arquivo de acesso aleat√≥rio.
Estudo de caso: programa de processamento de transa√ß√µes.

**E struturas de dados em C**
Estruturas autorreferenciadas.
Aloca√ß√£o din√¢mica de mem√≥ria.
Listas encadeadas.
Pilhas.
Filas.
√Årvores.

**O pr√©-processador em C**
A diretiva #include do pr√©-processador.
A diretiva #define do pr√©-processador: constantes simb√≥licas.
A diretiva #define do pr√©-processador: macros.
Compila√ß√£o condicional.
As diretivas #error e #pragma do pr√©-processador.
Operadores # e ##.
N√∫meros de linhas.
Constantes simb√≥licas predefinidas.
Asser√ß√µes.

**Outros t√≥picos sobre C**
Redirecionamento de entrada/sa√≠da........................................................................................................425
Listas de argumentos de tamanhos vari√°veis..........................................................................................426
Uso de argumentos na linha de comando...............................................................................................428
Notas sobre a compila√ß√£o de programas de m√∫ltiplos arquivos-fonte....................................................429
T√©rmino de programas com exit e atexit..........................................................................................430
O qualificador de tipo volatile............................................................................................................431
Sufixos para constantes inteiras e de ponto flutuante.............................................................................432
Mais sobre arquivos.................................................................................................................................432
Tratamento de sinais...............................................................................................................................434
Aloca√ß√£o din√¢mica de mem√≥ria: fun√ß√µes calloc e realloc................................................................436
Desvio incondicional com goto..............................................................................................................436

**C++: um C melhor ‚Äì introdu√ß√£o √† tecnologia de objeto**
15.1 Introdu√ß√£o...............................................................................................................................................443
15.2 C++......................................................................................................................................................443
15.3 Um programa simples: somando dois inteiros.......................................................................................443
15.4 Biblioteca-padr√£o de C++.....................................................................................................................445
xiv C: como programar
15.5 Arquivos de cabe√ßalho.............................................................................................................................446
15.6 Fun√ß√µes inline.........................................................................................................................................448
15.7 Refer√™ncias e par√¢metros de refer√™ncia..................................................................................................450
15.8 Listas de par√¢metros vazios.....................................................................................................................454
15.9 Argumentos default.................................................................................................................................455
15.10 Operador un√°rio de resolu√ß√£o de escopo................................................................................................457
15.11 Sobrecarga de fun√ß√£o..............................................................................................................................458
15.12 Templates de fun√ß√£o................................................................................................................................461
15.13 Introdu√ß√£o √† tecnologia de objetos e a UML............................................................................................463
15.14 Conclus√£o................................................................................................................................................465

**I ntrodu√ß√£o a classes e objetos**
16.1 Introdu√ß√£o...............................................................................................................................................471
16.2 Classes, objetos, fun√ß√µes-membro e dados-membro..............................................................................471
16.3 Defini√ß√£o de uma classe com uma fun√ß√£o-membro..............................................................................472
16.4 Defini√ß√£o de uma fun√ß√£o-membro com um par√¢metro.........................................................................474
16.5 Dados-membro, fun√ß√µes set e fun√ß√µes get..........................................................................................477
16.6 Inicializa√ß√£o de objetos com construtores..............................................................................................483
16.7 Introdu√ß√£o de uma classe em um arquivo separado para reutiliza√ß√£o...................................................486
16.8 Separa√ß√£o da interface de implementa√ß√£o..............................................................................................489
16.9 Valida√ß√£o de dados com fun√ß√µes set......................................................................................................494
16.10 Conclus√£o................................................................................................................................................498

**Classes: uma vis√£o mais detalhada, parte 1**
17.1 Introdu√ß√£o...............................................................................................................................................505
17.2 Estudo de caso da classe time.................................................................................................................505
17.3 Escopo de classe e acesso a membros de classes....................................................................................511
17.4 Separa√ß√£o de interface e implementa√ß√£o................................................................................................513
17.5 Fun√ß√µes de acesso e fun√ß√µes utilit√°rias...................................................................................................513
17.6 Estudo de caso da classe time: construtores com argumentos default..................................................516
17.7 Destrutores..............................................................................................................................................521
17.8 Quando construtores e destrutores s√£o chamados.................................................................................521
17.9 Estudo de caso da classe time: uma armadilha sutil ‚Äî
retorno de uma refer√™ncia a um dado-membro private.........................................................................524
17.10 Atribui√ß√£o usando c√≥pia membro a membro default..............................................................................526
17.11 Conclus√£o................................................................................................................................................528

**Classes: uma vis√£o mais detalhada, parte 2**
18.1 Introdu√ß√£o...............................................................................................................................................535
18.2 Objetos const (constantes) e fun√ß√µes-membro const.........................................................................535
18.3 Composi√ß√£o: objetos como membros de classes....................................................................................543
Sum√°rio xv
18.4 Fun√ß√µes friend e classes friend.........................................................................................................549
18.5 Uso do ponteiro this..............................................................................................................................551
18.6 Membros de classe static....................................................................................................................556
18.7 Abstra√ß√£o de dados e oculta√ß√£o de informa√ß√µes......................................................................................560
18.8 Conclus√£o................................................................................................................................................562

**Sobrecarga de operadores**
19.1 Introdu√ß√£o...............................................................................................................................................568
19.2 Fundamentos da sobrecarga de operadores............................................................................................568
19.3 Restri√ß√µes na sobrecarga de operadores.................................................................................................569
19.4 Fun√ß√µes operador como membros de classe versus fun√ß√µes operador como fun√ß√µes globais...............571
19.5 Sobrecarga dos operadores de inser√ß√£o em stream e de extra√ß√£o de stream..........................................572
19.6 Sobrecarga de operadores un√°rios..........................................................................................................575
19.7 Sobrecarga de operadores bin√°rios.........................................................................................................575
19.8 Gerenciamento din√¢mico de mem√≥ria....................................................................................................576
19.9 Estudo de caso: classe Array.................................................................................................................577
19.10 Convers√£o de tipos..................................................................................................................................587
19.11 Cria√ß√£o de uma classe String...............................................................................................................588
19.12 Sobrecarga de ++ e --.............................................................................................................................589
19.13 Estudo de caso: uma classe Date............................................................................................................590
19.14 Classe string da biblioteca-padr√£o.......................................................................................................595
19.15 Construtores explicit..........................................................................................................................597
19.16 Classes proxy...........................................................................................................................................600
19.17 Conclus√£o................................................................................................................................................603

**Programa√ß√£o orientada a objetos: heran√ßa**
20.2 Classes-base e classes derivadas.
20.3 Membros protected.
20.4 Rela√ß√£o entre classe-base e classe derivada.
20.4.1 Cria√ß√£o e uso de uma classe FuncionarioComissao.
20.4.2 Cria√ß√£o e uso de uma classe FuncionarioBaseMaisComissao sem o uso de heran√ßa.
20.4.3 Cria√ß√£o de uma hierarquia de heran√ßa FuncionarioComissao ‚Äî FuncionarioBaseMaisComissao.
20.4.4 Hierarquia de heran√ßa FuncionarioComissao ‚Äî
FuncionarioBaseMaisComissao usando dados protected.
20.4.5 Hierarquia de heran√ßa FuncionarioComissao ‚Äî
FuncionarioBaseMaisComissao usando dados private.
20.5 Construtores e destrutores em classes derivadas.
20.6 Heran√ßas public, protected e private.
20.7 Engenharia de software com heran√ßa.

**Programa√ß√£o orientada a objeto: polimorfismo**
21.2 Exemplos de polimorfismo.
21.3 Rela√ß√µes entre objetos em uma hierarquia de heran√ßa.
21.3.1 Chamada de fun√ß√µes de classe-base por objetos de classe derivada.
21.3.2 Visando ponteiros de classe derivada em objetos de classe-base.
21.3.3 Chamadas de fun√ß√£o-membro de classe derivada com ponteiros de classe-base.
21.3.4 Fun√ß√µes virtuais.
21.3.5 Resumo das atribui√ß√µes permitidas entre objetos e ponteiros de classe-base e derivada.
21.4 Campos de tipo e comandos switch.
21.5 Classes abstratas e fun√ß√µes virtuais puras.
21.6 Estudo de caso: um sistema de folha de pagamento usando polimorfismo.
21.6.1 Cria√ß√£o da classe-base abstrata Funcionario.
21.6.2 Cria√ß√£o da classe derivada concreta FuncionarioSalario.
21.6.3 Cria√ß√£o da classe derivada concreta FuncionarioHora.
21.6.4 Cria√ß√£o da classe derivada concreta FuncionarioComissao.
21.6.5 Cria√ß√£o da classe derivada concreta indireta FuncionarioBaseMaisComissao.
21.6.6 Demonstra√ß√£o do processamento polim√≥rfico.
21.7 Polimorfismo, fun√ß√µes virtuais e vincula√ß√£o din√¢mica ‚Äòvistos por dentro‚Äô.
21.8 Estudo de caso: sistema de folha de pagamento usando polimorfismo e informa√ß√£o de tipo em tempo de execu√ß√£o com downcasting, dynamic_cast, typeid e type_info.
21.9 Destrutores virtuais.

**Templates**
22.2 Templates de fun√ß√£o.
22.3 Sobrecarga de templates de fun√ß√£o.
22.4 Templates de classe.
22.5 Par√¢metros n√£o tipo e tipos default para templates de classe.

**Entrada e sa√≠da de streams**
23.2 Streams.
23.2.1 Streams cl√°ssicos versus streams-padr√£o.
23.2.2 Arquivos de cabe√ßalho da biblioteca iostream.
23.2.3 Classes e objetos de entrada/sa√≠da de streams.
23.3 Sa√≠da de streams.
23.3.1 Sa√≠da de vari√°veis char *.
23.3.2 Sa√≠da de caracteres usando a fun√ß√£o-membro put.
23.4 Entrada de streams.
23.4.1 Fun√ß√µes-membro get e getline.
23.4.2 Fun√ß√µes-membro peek, putback e ignore de istream.
23.4.3 E/S segura quanto ao tipo.
23.5 E/S n√£o formatada com read, write e gcount.
23.6 Introdu√ß√£o a manipuladores de streams.
23.6.1 Base do stream de inteiros: dec, oct, hex e setbase.
23.6.2 Precis√£o em ponto flutuante (precision, setprecision).
23.6.3 Largura de campo (width, setw).
23.6.4 Manipuladores de stream de sa√≠da definidos pelo usu√°rio.
23.7 Tipos de formato do stream e manipuladores de stream.
23.7.1 Zeros √† direita e pontos decimais (showpoint).
23.7.2 Alinhamento (left, right e internal).
23.7.3 Preenchimento (fill, setfill).
23.7.4 Base do stream de inteiros (dec, oct, hex, showbase).
23.7.5 N√∫meros em ponto flutuante; nota√ß√µes cient√≠fica e fixa (scientific, fixed).
23.7.6 Controle de mai√∫sculas/min√∫sculas (uppercase).
23.7.7 Especifica√ß√£o do formato booleano (boolalpha).
23.7.8 Inicializa√ß√£o e reinicializa√ß√£o do estado original com fun√ß√£o-membro flags.
23.8 Estados de erro do stream.
23.9 Vincula√ß√£o de um stream de sa√≠da a um stream de entrada.

**Tratamento de exce√ß√µes**
24.2 Vis√£o geral do tratamento de exce√ß√£o.
24.3 Exemplo: tratando uma tentativa de divis√£o por zero.
24.4 Quando o tratamento de exce√ß√£o deve ser usado.
24.5 Indica√ß√£o de uma exce√ß√£o.
24.6 Especifica√ß√µes de exce√ß√£o.
24.7 Processamento de exce√ß√µes inesperadas.
24.8 Desempilhamento.
24.9 Construtores, destrutores e tratamento de exce√ß√µes.
24.10 Exce√ß√µes e heran√ßa.
24.11 Processamento de falhas de new.
24.12 Classe auto_ptr e aloca√ß√£o din√¢mica de mem√≥ria.
24.13 Hierarquia de exce√ß√µes da biblioteca-padr√£o.
24.14 Outras t√©cnicas de tratamento de erros.

## Recursos Utilizados üöÄ

* **[Visual Studio Code](https://code.visualstudio.com/?WT.mc_id=meanserverlessworkshop-github-gllemos)**

## Daqui por diante continuar editando ‚≠êÔ∏è

Editar

## Pr√©-requisitos üìå

Editar

## Executando a Aplica√ß√£o Localmente ‚ùóÔ∏è

### Executando a aplica√ß√£o no lado do Front-End

1) Instalar os pacotes com o comando: (dentro da pasta `front`)

``` 
> Editar
```

2) Depois executar o seguinte comando para executar a aplica√ß√£o (dentro da pasta `front`):

```
> Editar
```

### Editar

Antes de iniciar os passos abaixo √© muito importante que voc√™ execute nesse momento o MongoDb localmente!

1) Instalar os pacotes com o comando: (dentro da pasta `api`)

``` 
> npm install
```

2) Depois executar o seguinte comando para executar a aplica√ß√£o (dentro da pasta `api`):

```
> nodemon
```

Depois bastam abrir o postamn em **localhost:8000** e testar as requisi√ß√µes

E v√≤il√°! :heart: :heart:

## Consumindo as API's no Azure Functions(Mongo x CosmosDb) ‚ö°Ô∏è

Visando facilitar o desenvolvimento e agilidade do projeto, j√° criei duas API que consomem esse projeto no Front-End. Para isso, seguem os links das apis:

### API via MongoDb - Azure Functions

Essa API persiste localmente no MongoDb via Azure Functions.

Para executar, bastam seguir os seguintes passos:

1. Baixar o projeto abaixo:

- **[CRUD Serverless MongoDb](https://github.com/glaucia86/crud-serverless-mongodb)**

2. Instalar as depend√™ncias necess√°rias com o comando:

```bash
> npm i
```

3. Criar um arquivo chamado: `local.settings.json` e incluir o bloco de c√≥digo abaixo:

```json
{
  "IsEncrypted": false,
  "Values": {
    "FUNCTIONS_WORKER_RUNTIME": "node",
    "AzureWebJobsStorage": "{AzureWebJobsStorage}"
  },
  "Host": {
    "LocalHttpPort": 7071,
    "CORS": "*"
  }
}
```
4. Execute o comando:

```bash
> func host start
```

E ele ir√° listar todos os endpoints criados e necess√°rios para persistir juntamente com o nosso Front-End.

5. Agora abre o projeto `front` e v√£o at√©: `src -> app -> funcionario.service.ts`

6. Ao entrar no arquivo `funcionario.service.ts`, basta alterar a uri para: `http://localhost:7071/api`

7. Execute o projeto Angular com o comando: 

```bash
> ng server -o
```

E v√≤il√°! S√≥ come√ßar a persistir!

### API via CosmosDb - Azure Functions

1. Baixar o projeto abaixo:

- **[CRUD Serverless CosmosDb](https://github.com/glaucia86/crud-serverless-cosmosdb)**

2. Instalar as depend√™ncias necess√°rias com o comando:

```bash
> npm i
```

3. Criar um arquivo chamado: `local.settings.json` e incluir o bloco de c√≥digo abaixo:

```json
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "",
    "FUNCTIONS_WORKER_RUNTIME": "node",
    "CosmosDbUrl": "<cosmos-db-url>",
    "CosmosDBUser": "crud-serverless-wavy",
    "CosmosDBPassword": "<cosmos-db-password>"
  },
  "Host": {
    "LocalHttpPort": 7071,
    "CORS": "*"
  }
}
```

4. Execute o comando:

```bash
> func host start
```

E ele ir√° listar todos os endpoints criados e necess√°rios para persistir juntamente com o nosso Front-End.

5. Agora abre o projeto `front` e v√£o at√©: `src -> app -> funcionario.service.ts`

6. Ao entrar no arquivo `funcionario.service.ts`, basta alterar a uri para: `http://localhost:7071/api`

7. Execute o projeto Angular com o comando: 

```bash
> ng server -o
```

E v√≤il√°! S√≥ come√ßar a persistir!

### Quero migrar os dados persistidos localmente para o CosmosDb... Como fa√ßo?!

O processo de migra√ß√£o dos dados localmente persistidos pelo MongoDb para o CosmosDb √© bem simples. Por√©m, recomendo que para deixar o processo mais f√°cil que baixem o **[MongodB Compass GUI](https://www.mongodb.com/download-center/compass)** e possuir uma conta do **[Conta - Azure](https://azure.microsoft.com/pt-br/?WT.mc_id=meanserverlessworkshop-github-gllemos)**. Tendo esses dois recursos,poderemos seguir com os seguintes passos abaixo:

1. Passo: abre o portal Azure e crie um Grupo de Recursos. Se tiver j√° um criado, √≥timo!

```bash
> meanServerlessResourceGroup
```

2. Passo: agora vamos criar o Base de dados no Azure CosmosDb. Para isso, abre o seu bash no Portal Azure e execute os seguintes comandos abaixo:

```bash
> crud--serverless-<inclua-seu-nome>

> az cosmosdb create --name crud--serverless-<inclua-seu-nome> --resource group meanServerlessResourceGroup --kind MongoDB
```

3. Abre o recurso rec√©m criado e capture as connections strings (primary key) criada no passo anterior.

4. Passo: agora vamos importar os dados localmente do MongoDb para o CosmosDb. Para isso, bastam abrir o MongoDb Compass e clicar em export file e salvar num local onde voc√™ deseja.

5. Passo: agora vamos executar o seguinte comando abaixo. Esse comando ser√° respons√°vel por migrar o arquivo criado no passo anterior para enviar para o CosmosDb. 

```bash
> mongoimport.exe --host crud--serverless-<inclua-seu-nome>.documents.azure.com:10255 -u crud--serverless-<inclua-seu-nome> -p <primary-key-criada-cosmosdb> --ssl --sslAllowInvalidCertificates --db crud--serverless-<inclua-seu-nome> --collection funcionarios --file funcionarios.json
```
E pronto! Ao abrir o Portal Azure e acessar o recurso do Azure CosmosDb, ver√° que os seus dados locais, foram migrados com sucesso no Azure CosmosDb!

## Deploy para o Azure ‚òÅÔ∏è

Para realizar o deploy da aplica√ß√£o ao Azure precisamos seguir com alguns pessos:

Mas antes, v√° at√© a pasta `front` e execute o seguinte o seguinte comando:

```bash
> ng build
```

Esse comando ir√° gerar uma pasta chamada `dist`. E √© justamente essa pasta que precisaremos para realizar o deploy da nossa aplica√ß√£o MEAN ao Azure.

1. Execute o seguinte comando dentro da pasta `dist` com o seguinte comando: 

```bash
> az webapp up -n <nombre-de-la-app>
```

E pronto! Agora podemos abrir a nossa aplica√ß√£o no browser!

## Links & Recursos Importantes ‚≠êÔ∏è

Durante o workshop, comentei sobre importantes documenta√ß√µes, links e recursos que podem auxiliar o seu conhecimento sobre Serverless & Azure Functions

- ‚úÖ **[Azure para devs JavaScript & Node.js](https://docs.microsoft.com/pt-br/javascript/azure/?WT.mc_id=meanserverlessworkshop-github-gllemos&view=azure-node-latest)**
- ‚úÖ **[Documenta√ß√£o Azure Functions](https://docs.microsoft.com/pt-br/azure/azure-functions/?WT.mc_id=meanserverlessworkshop-github-gllemos)**
- ‚úÖ **[Criando a sua Primeira Fun√ß√£o no Visual Studio Code](https://docs.microsoft.com/pt-br/azure/azure-functions/functions-create-first-function-vs-code?WT.mc_id=meanserverlessworkshop-github-gllemos)**
- ‚úÖ **[Extens√£o Vs Code ‚Äì Azure Functions](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurefunctions&WT.mc_id=meanserverlessworkshop-github-gllemos)**
- ‚úÖ **[E-Book Gr√°tis - Azure Serverless Computing Cookbook](https://azure.microsoft.com/pt-br/resources/azure-serverless-computing-cookbook/?WT.mc_id=meanserverlessworkshop-github-gllemos)**
- ‚úÖ **[Cursos Gr√°tis - Azure Functions](https://docs.microsoft.com/pt-br/learn/paths/create-serverless-applications/?WT.mc_id=meanserverlessworkshop-github-gllemos)**

## Tenho D√∫vidas... O que Fa√ßo?! ‚ùì

Caso tenham d√∫vidas aos c√≥digos dos projetos relacionados aos workshops, sintam-se a vontade em abrir uma **[ISSUE AQUI](https://github.com/glaucia86/workshop-mean-serverless/issues)**. Assim que poss√≠vel, estarei respondendo as todas as d√∫vidas que tiverem!

**documenta√ß√£o em desenvolvimento**
