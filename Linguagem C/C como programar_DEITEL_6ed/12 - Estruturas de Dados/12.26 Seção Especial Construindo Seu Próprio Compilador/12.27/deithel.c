/*(Construindo um Compilador; Pré-requisito: Exercícios Completos7.18, 7.19, 12.12,12.13 e 12.26) Agora que a linguagem Simples foi apresentada (Exercício 12.26), analisaremos como construir nosso compilador Simples. Em primeiro lugar, examinamos o processo pelo qual um programa Simples é convertido para a LMS e executado pelo simulador Simpletron (veja a Fig. 12.27). Um arquivo contendo um programa Simples é lido pelo compilador e convertido para o código LMS. O código LMS é enviado para um arquivo em disco, no qual aparece uma instrução LMS por linha. O arquivo LMS é então carregado no simulador Simpletron e os resultados são enviados para um arquivo em disco e para a tela. Observe que o programa Simpletron desenvolvido no Exercício 7.19 recebia dados do teclado. Ele deve ser modificado para ler dados de um arquivo para que possa executar os programas produzidos por nosso compilador
O compilador realiza duas passadas do programa Simples para convertê-lo a LMS. A primeira
passada constrói uma tabela de símbolos na qual todos os números de linhas, nomes de variáveis e constantes do programa na linguagem Simples são armazenados com seu tipo e localização correspondente no código LMS final (a tabela de símbolos é analisada detalhadamente a seguir). A primeira passada também produz as instruções LMS correspondentes para cada instrução em Simples. Como veremos, se o programa em Simples possuir instruções que transferem o controle para uma linha posterior do programa, a primeira passada resulta em um programa LMS contendo algumas instruções incompletas. A segunda passada do compilador localiza e completa as instruções inacabadas e envia o programa LMS para um arquivo.

FIGURA 597

Primeira Passada
O compilador começa lendo uma sentença do programa na linguagem Simples para a memória. A linha deve ser separada em suas "partes" (ou "tokens", i.e., em "pedaços" de uma sentença) para processamento e compilação (a função strtok da biblioteca padrão pode ser usada para facilitar essa tarefa.) Lembre-se de que todas as instruções começam com um número de linha seguido de um comando. Quando o compilador divide uma sentença em partes, elas serão colocadas na tabela de símbolos se forem um número de linha, uma variável ou uma constante. Um número de linha só será colocado na tabela de símbolos se for a primeira parte de uma sentença. A tabelaSimbolos é um array de estruturas entradaTabela que representam cada símbolo do programa. Não há restrições quanto ao número de símbolos que podem aparecer em um programa. Portanto, tabelaSimbolos de um determinado programa pode ser grande. Por ora, faça com que tabelaSimbolos seja um array de 100 elementos. Você pode aumentar ou diminuir seu tamanho depois que o programa estiver funcionando.
A definição da estrutura entradaTabela é a seguinte:

    struct entradaTabela { int simbolo; 
    char tipo; /* }
    
Cada estrutura entradaTabela contém três membros. O membro simbolo é um inteiro que contém a representação ASCII de uma variável (lembre-se de que os nomes de variáveis são caracteres isolados), um número de linha ou uma constante. O membro tipo é um dos seguintes caracteres que indica o tipo do símbolo: ' C ' para uma constante, ' L ' para um número de linha ou ' V' para uma variável. O membro local contém o local da memória do Simpletron (00 a 99) à qual o símbolo se refere. A memória do Simpletron é um array de 100 inteiros no qual as instruções LMS e os dados são armazenados. Para um número de linha, o local é o elemento no array da memória do Simpletron na qual iniciam as instruções LMS para a sentença em linguagem Simples. Para uma variável ou uma constante, o local é o elemento no array da memória do Simpletron no qual a variável ou constante está armazenada. As variáveis e constantes são alocadas do final da memória do Simpletron para a frente. A primeira variável ou constante é armazenada no local 99, a próxima, no local 98 etc.
A tabela de símbolos desempenha um papel importante na conversão de programas na linguagem Simples para LMS. Aprendemos no Capítulo 7 que uma instrução em LMS é um inteiro de quatro dígitos composto de duas partes — o código de operação e o operando. O código de operação é determinado pelos comandos em Simples. Por exemplo, o comando input da linguagem Simples corresponde ao código de operação 10 (read, ou ler) e o comando print da linguagem Simples corresponde ao código de operação 11 (write, ou escrever). O operando é um local da memória que contém os dados nos quais o código da operação realiza sua tarefa (e.g., o código de operação 10 lê um valor do teclado e armazena-o no loca da memória especificado pelo operando). O compilador consulta tabelaSimbolos para determinar o local da memória de Simpletron de cada símbolo para que o local correspondente possa ser usado para comple- J tar as instruções LMS.
A compilação de cada instrução da linguagem Simples se baseia em seu comando. Por exemplo, depois de o número de linha em uma instrução rem ser inserido na tabela de símbolos, o restante da instrução é ignorado pelo compilador porque um comentário só tem a finalidade de documentar o programa. As instruções input, print, goto e end correspondem às instruções read, write, branch (para um local específico) e halt. As instruções que possuírem esses comandos da linguagem Simples são convertidas diretamente em LMS (observe que a instrução goto pode conter uma referência indeterminada se o número de linha especificado se referir a uma instrução mais adiante no arquivo de programa Simples; algumas vezes isso é chamado referência antecipada).
Quando uma instrução goto é compilada com uma referência indeterminada, a instrução LMS deve ser marcada (sinalizada, ou flagged) para indicar que a segunda passada do compilador deve completar a instrução. Os sinalizadores são armazenados no array f lags de 100 elementos do tipo int, no qual cada elemento é inicializado com -1. Se o local da memória, ao qual o número da linha em um programa Simples se refere, ainda não for conhecido (i.e., não estiver na tabela de símbolos), o número da linha é armazenado no array f lags no elemento com o mesmo subscrito que a instrução incompleta. O operando da instrução incompleta é definido temporariamente como 00. Por exemplo, uma instrução de desvio incondicional (fazendo uma referência antecipada) é deixada como +4 000 até a segunda passada do compílador. Em breve será descrita a segunda passada do compilador.
A compilação das instruções if /goto e let é mais complicada que outras instruções — elas são as únicas instruções que produzem mais de uma instrução LMS. Para uma instrução if/goto, o compilador produz código para examinar a condição e para desviar para outra linha, se necessário. O resultado do desvio pode ser uma referência indeterminada. Cada um dos operadores relacionais e de igualdade pode ser simulado usando as instruções de desvio zero e desvio negativo da LMS (ou possivelmente uma combinação de ambas).
Para uma instrução let, o compilador produz código para calcular uma expressão aritmética complexa consistindo em variáveis inteiras e/ou constantes. As expressões devem separar cada operando e operador por meio de espaços. Os Exercícios 12.12 e 12.13 apresentaram o algoritmo de conversão infixada-para-posfixada e o algoritmo de cálculo posfixado usado por compiladores na avaliação de expressões. Antes de prosseguir com nosso compilador, você deve completar cada um daqueles exercícios. Quando um compilador encontra uma expressão, ele,a converte da notação infixada para a notação posfixada e então calcula a expressão.
Como o compilador produz linguagem de máquina para calcular uma expressão que contém variáveis?
O algoritmo de cálculo posfixado contém uma "conexão" que permite ao nosso compilador gerar instruções LMS em vez de realmente calcular a expressão. Para possibilitar a existência dessa "conexão" no compilador, o algoritmo de cálculo posfixado deve ser modificado para pesquisar na tabela de símbolos cada símbolo que encontrar (e possivelmente inseri-lo), determinar o local da memória correspondente àquele símbolo e colocar na pilha o local da memória em vez do símbolo. Quando um operador é encontrado em uma expressão posfixada, os dois locais da memória no topo da pilha são removidos e é produzida linguagem de máquina para realizar a operação, usando os locais da memória como operandos. O resultado de cada subexpressão é armazenado em um local temporário da memória e colocado novamente na pilha para que o cálculo da expressão posfixada possa continuar. Quando o cálculo posfixado for concluído, o local da memória que contém o resultado é o único local que resta na pilha. Ele é removido e são geradas as instruções LMS para atribuir o resultado à variável à esquerda da instrução let.

Segunda Passada

A segunda passada do compilador realiza duas tarefas: determinar todas as referências indeterminadas e enviar o código LMS para um arquivo. A determinação das referências ocorre da seguinte maneira: 
1) Procure no array flags uma referência indeterminada (i.e., um elemento com valor diferente de 1). 
2) Localize no array tabelaSimbolos a estrutura que contém o símbolo armazenado no array flags (certifique-se de que o tipo do símbolo é ' L' para um número de linha). 
3) Insira o local da memória para o membro da estrutura local na instrução com a referência indeterminada (lembre-se de que uma instrução que contém uma referência indeterminada tem operando 00).
4) Repita os passos 1, 2 e 3 até chegar ao fim do array flags. Depois de o processo de resolução ser concluído, todo o array que contém o código LMS é enviado para um arquivo em disco com uma instrução LMS por linha. Esse arquivo pode ser lido pelo Simpletron para execução (depois de o simulador ser modificado para ler os dados de entrada a partir de um arquivo).
*/