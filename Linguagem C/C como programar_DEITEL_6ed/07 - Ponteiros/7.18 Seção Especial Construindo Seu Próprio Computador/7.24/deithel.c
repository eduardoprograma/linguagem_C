/*(Classificação Rápida) Nos exemplos e exercícios do Capítulo 6, analisamos as técnicas de classificação de bolhas, classificação de depósitos e classificação de seleção. Apresentamos agora uma técnica de classificação recursiva chamada Classificação Rápida (Quicksort). O algoritmo básico para um array unidimensional de valores é o seguinte: 
1) Etapa de Partição: Tome o primeiro elemento do array não-ordenado e determine seu local final no array classificado. Isso ocorre quando todos os valores à esquerda do elemento no array forem menores do que ele e todos os valores à direita do elemento no array forem maiores do que ele. Agora temos um elemento em seu local adequado e dois subarrays não-ordenados. 
2) Etapa de Recursão: Realizar a etapa 1 em cada subarray não-ordenado. Cada vez que a etapa 1 é realizada em um subarray, outro elemento é colocado em sua posição final no array ordenado, e dois subarrays não-ordenados são criados. Quando um subarray consistir em um elemento, ele deve ser ordenado, portanto aquele elemento está na sua posição final. O algoritmo básico parece muito simples, mas como determinar a posição final do primeiro elemento de cada subarray? Como exemplo, considere o seguinte conjunto de valores (o elemento em negrito é o elemento de partição — ele será colocado em sua posição final no array ordenado): 37 2 6 4 89 8 2 6 4 89 10 8 12 10 68 45

1) Iniciando com o elemento da extremidade esquerda do array, compare cada elemento com 37 até que seja encontrado um elemento menor do que 37, então permute 37 e esse elemento. O primeiro elemento menor do que 37 é 12, portanto 37 e 12 são permutados. O novo array é: 12 37 68 45 
O elemento 12 está em itálico para indicar que acabou de trocar de lugar com 37. 
2) Começando pela esquerda do array, mas com o elemento depois do 12, compare cada elemento com 3 até encontrar um elemento maior do que 37, e então permute 37 com esse elemento. O primeiro elemento maior do que 37 é 89, portanto 37 e 89 são permutados. O novo array é: 12 2 6 4 37 8 2 6 4 10 10 8 89 37 68 45
3) Começando pela direita, mas com o elemento antes de 89, compare cada elemento com 37 até que seja encontrado um elemento menor do que 37, e então permute 37 com esse elemento. O primeiro elemento menor do que 37 é 10, portanto 37 e 10 são permutados. O novo array é 12 89 68 45
4) Começando pela esquerda, mas com o elemento após o 10, compare cada elemento com 37 até que seja encontrado um elemento maior do que 37, e então permute 37 com esse elemento. Não há mais tos maiores do que 37, portanto ao compararmos 37 com ele mesmo sabemos que 37 foi colocado em sua posição final no array ordenado. Depois de a partição ter sido aplicada no array anterior, ficam-se com dois arrays não-ordenados. O subarray com valores menores do que 37 contém 12, 2, 6,4, 10 e 8. O subarray com valores maiores do que 37 contêm 89, 68 e 45. A ordenação continua da mesma maneira que no array original. Com base na análise anterior, escreva uma função recursiva quicksort para ordenar um array inteiro unidimensional. A função deve receber como argumentos um array inteiro, um subscrito inicial e um subescrito final. A função partição deve ser chamada por quicksort para realizar a etapa de partição.*/